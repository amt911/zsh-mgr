use anyhow::Result;
use colored::Colorize;
use std::fs;
use std::path::PathBuf;
use zsh_mgr_rs::config::{Config, PluginList, real_home_dir};

pub fn run(zshrc_path: Option<String>) -> Result<()> {
    let config = Config::load()?;
    let plugin_list = PluginList::load(&config)?;
    
    if plugin_list.list().is_empty() {
        println!("{} No plugins installed", "â„¹ï¸".cyan());
        println!("Install plugins with: zsh-mgr add <user/repo>");
        return Ok(());
    }
    
    // Generate plugin lines with FULL repo names (user/repo)
    let mut load_lines = Vec::new();
    load_lines.push("# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•".to_string());
    load_lines.push("# PLUGINS - Auto-generated by zsh-mgr".to_string());
    load_lines.push("# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•".to_string());
    load_lines.push("".to_string());
    
    for plugin in plugin_list.list() {
        // Use FULL repository name (user/repo) instead of just plugin name
        load_lines.push(format!("plugin {}", plugin.name));
    }
    
    let output = load_lines.join("\n");
    
    // Determine .zshrc path
    let zshrc = if let Some(path) = zshrc_path {
        PathBuf::from(shellexpand::tilde(&path).to_string())
    } else {
        real_home_dir()
            .ok_or_else(|| anyhow::anyhow!("Could not find home directory"))?
            .join(".zshrc")
    };
    
    // Check if .zshrc exists
    if !zshrc.exists() {
        println!("{} {} not found", "âš ï¸".yellow(), zshrc.display());
        println!("\n{}", "Generated plugin loading code:".bright_cyan());
        println!("{}", output);
        println!("\n{} Add this to your .zshrc manually", "ğŸ’¡".bright_cyan());
        return Ok(());
    }
    
    // Read current .zshrc
    let content = fs::read_to_string(&zshrc)?;
    
    // Check if already has plugin calls
    if content.contains("plugin ") && content.contains("/") {
        println!("{} {} already has plugin calls", "â„¹ï¸".cyan(), zshrc.display());
        println!("\n{}", "Current plugins in zsh-mgr:".bright_cyan());
        for plugin in plugin_list.list() {
            println!("  plugin {}", plugin.name);
        }
        println!("\n{}", "Options:".bright_cyan());
        println!("  1. Update manually in {}", zshrc.display());
        println!("  2. Or copy the lines above");
        return Ok(());
    }
    
    // Find insertion point (after sourcing zsh-sources.zsh)
    let marker = "source $ZSH_CONFIG_DIR/zsh-sources.zsh";
    
    if let Some(pos) = content.find(marker) {
        // Find the end of the line
        let line_end = content[pos..].find('\n').map(|i| pos + i).unwrap_or(content.len());
        
        let mut new_content = String::new();
        new_content.push_str(&content[..=line_end]);
        new_content.push_str("\n\n");
        new_content.push_str(&output);
        new_content.push_str("\n");
        new_content.push_str(&content[line_end + 1..]);
        
        // Write back
        fs::write(&zshrc, new_content)?;
        
        println!("{} Updated {}", "âœ“".green(), zshrc.display());
        println!("\n{}", "Added plugin loading:".bright_cyan());
        for plugin in plugin_list.list() {
            println!("  {} plugin {}", "â€¢".green(), plugin.name);
        }
        println!("\n{} Run: source ~/.zshrc", "ğŸ’¡".bright_cyan());
    } else {
        println!("{} Could not find insertion point in {}", "âš ï¸".yellow(), zshrc.display());
        println!("Looking for: {}", marker);
        println!("\n{}", "Generated plugin loading code:".bright_cyan());
        println!("{}", output);
        println!("\n{} Add this to your .zshrc manually after sourcing zsh-sources.zsh", "ğŸ’¡".bright_cyan());
    }
    
    Ok(())
}
